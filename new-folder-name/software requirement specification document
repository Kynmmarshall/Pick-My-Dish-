% PickMyDish_SRS.tex
\documentclass[12pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{array}
\usepackage{enumitem}
\usepackage{titlesec}
\usepackage{fancyhdr}
\usepackage{setspace}
\usepackage{caption}
\usepackage{bookmark}

\geometry{margin=1in}
\setstretch{1.15}
\titleformat{\chapter}{\Large\bfseries}{\thechapter.}{0.5em}{}
\titleformat{\section}{\large\bfseries}{\thesection}{0.5em}{}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{PickMyDish — SRS}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

\begin{document}

\begin{titlepage}
    \centering
    {\Huge \bfseries Software Requirements Specification}\\[0.6cm]
    {\Large \bfseries PickMyDish: What Should I Eat Today?}\\[1.2cm]
    {\Large Prepared by: \underline{Project Team}}\\[0.3cm]
    {\large Course: Software Design and Modelling}\\[2.0cm]
    {\large Version: 1.0}\\[0.1cm]
    {\large Date: \today}
    \vfill
    \begin{flushleft}
    \textbf{Document History:}\\
    \begin{tabular}{p{2.5cm} p{9cm}}
    Version & Notes \\
    \hline
    1.0 & Initial SRS, based on project proposal \\
    \end{tabular}
    \end{flushleft}
\end{titlepage}

\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures
\newpage
\pagenumbering{arabic}

\chapter{Introduction}
\section{Purpose}
This Software Requirements Specification (SRS) document describes the functional and non-functional requirements, interfaces, data models, constraints, and acceptance criteria for \emph{PickMyDish} — a mobile application that helps users decide what to eat based on (1) ingredients they already have, (2) their current mood, and (3) the time available to prepare a meal.

\section{Scope}
PickMyDish is a cross-platform mobile application built with Flutter. It will provide:
\begin{itemize}
    \item Personalized recipe suggestions.
    \item Quick filtering based on ingredients, mood, and available time.
    \item Recipe details with images, ingredients list, step-by-step instructions.
    \item Ability to upload recipes and images.
    \item User accounts, profile management, and favorites.
    \item Offline support via local SQLite storage.
\end{itemize}

\section{Intended audience}
\begin{itemize}
    \item Course instructor and assessors.
    \item Developers implementing the application.
    \item Testers and QA engineers.
    \item End-user representatives (for acceptance criteria).
\end{itemize}

\section{References}
The SRS is derived from the project proposal and architecture description provided by the team. :contentReference[oaicite:1]{index=1}

\section{Definitions, acronyms and abbreviations}
\begin{description}
    \item[API] Application Programming Interface
    \item[UI] User Interface
    \item[SRS] Software Requirements Specification
    \item[DB] Database
    \item[CRUD] Create, Read, Update, Delete
    \item[JSON] JavaScript Object Notation
\end{description}

\chapter{Overall description}
\section{Product perspective}
PickMyDish is a new, standalone mobile application. It uses a RESTful backend (base URL: \texttt{http://38.242.246.126:3000}) and a local SQLite database for offline capability. The frontend is implemented with Flutter, using Provider for state management.

\section{Product functions (high level)}
\begin{itemize}
    \item User authentication: register, login, guest login, Google sign-in.
    \item Profile management: update username, upload profile picture.
    \item Recipe browsing: view recipes, search, filter, view recipe detail.
    \item Recipe personalization: find recipes by ingredients, mood, and time.
    \item Favorites management: mark/unmark favorites, view favorites.
    \item Recipe upload: create new recipes with optional image upload.
    \item Offline persistence: cache recipes and images locally.
\end{itemize}

\section{User classes and characteristics}
\begin{itemize}
    \item \textbf{Anonymous user / Guest:} Can browse recipes and use basic features without saving data.
    \item \textbf{Registered user:} Can save favorites, upload recipes, edit profile.
    \item \textbf{Administrator / Maintainer (optional):} Manage backend data (not in scope for initial version).
\end{itemize}

\section{Operating environment}
\begin{itemize}
    \item Mobile devices: Android and iOS (Flutter).
    \item Backend: REST API hosted at the configured server.
    \item Local storage: SQLite (sqflite Flutter package).
    \item Network: intermittent connectivity; app must support offline read and local changes queueing.
\end{itemize}

\section{Design and implementation constraints}
\begin{itemize}
    \item Must use Flutter SDK compatible with project configuration (proposal referenced SDK \textasciicircum3.9.2).
    \item Use Provider for state management.
    \item Use sqflite for local persistence.
    \item Image caching via cached\_network\_image.
    \item Backend URL is fixed for the initial version: \texttt{http://38.242.246.126:3000}.
\end{itemize}

\section{Assumptions and dependencies}
\begin{itemize}
    \item Backend API endpoints described in the proposal will be available and follow the expected contract.
    \item The device has sufficient storage for caching images and local DB.
    \item Users have Internet access for first-time sync; offline fallback will be supported thereafter.
\end{itemize}

\chapter{Specific requirements}

\section{External interface requirements}

\subsection{User interfaces}
\begin{itemize}
    \item Dark-themed UI with orange accents; Times New Roman font (times.ttf).
    \item Screens: Splash, Login, Register, Home, Recipes list, Recipe detail, Favorites, Profile, Recipe upload.
    \item Input fields must include validation (email format, password strength indicator).
    \item Recipe cards: image, title, category, cooking time, favorite icon.
\end{itemize}

\subsection{Hardware interfaces}
Standard mobile device sensors are optional (not required in initial version).

\subsection{Software interfaces}
\begin{itemize}
    \item REST API endpoints for authentication, profile, recipe CRUD, image upload/download.
    \item Local SQLite database schema as defined below.
    \item Image caching and local cache manager APIs.
\end{itemize}

\subsection{Communication interfaces}
HTTP(S) using JSON payloads and multipart/form-data for image uploads.

\section{Functional requirements}
Each functional requirement below has an ID for traceability.

\subsection*{Authentication and user management}
\begin{itemize}[leftmargin=*,label={}]
    \item[FR-01] \textbf{User registration:} System shall allow a user to register providing username, email and password. Validation: unique email, password confirmation, password strength feedback.
    \item[FR-02] \textbf{User login:} System shall allow registered users to log in with email and password; successful login returns user profile (id, username, email, profile image path).
    \item[FR-03] \textbf{Guest login:} System shall allow user to login as guest with limited features.
    \item[FR-04] \textbf{Google sign-in:} Optional integration for OAuth Google Sign-In.
    \item[FR-05] \textbf{Update username:} Users can update their username (API: updateUsername).
    \item[FR-06] \textbf{Profile picture upload:} Users can upload a profile image (multipart form-data).
    \item[FR-07] \textbf{Logout:} Clear session, cached user data, and optionally clear local cache.
\end{itemize}

\subsection*{Recipe management}
\begin{itemize}
    \item[FR-08] \textbf{Fetch recipes:} System shall fetch a list of recipes from the server (getRecipes) and store locally.
    \item[FR-09] \textbf{View recipe detail:} User can view full recipe details including name, category, cooking time, calories, list of ingredients, steps, mood tags, and image.
    \item[FR-10] \textbf{Search and filter:} Users can search by name, category, and filter by mood and cooking time.
    \item[FR-11] \textbf{Personalize suggestions:} Given a set of available ingredients, selected mood(s), and available time, system shall return matching recipes (personalizeRecipes).
    \item[FR-12] \textbf{Upload recipe:} Authenticated users can create/upload recipes with optional image (multipart), providing name, category, time, calories, ingredients, instructions, mood tags.
    \item[FR-13] \textbf{Favorites:} Users can mark/unmark recipes as favorite (toggleFavorite), and view favorites list.
    \item[FR-14] \textbf{Offline mode:} Recipes loaded and favorited should be accessible offline via local SQLite DB.
\end{itemize}

\subsection*{Image handling}
\begin{itemize}
    \item[FR-15] \textbf{Image source detection:} Widget should detect if image path is local (assets/) or remote and build full URL for remote images using base path.
    \item[FR-16] \textbf{Caching:} Remote images to be cached using cached\_network\_image and a cache manager.
    \item[FR-17] \textbf{Loading/Error UI:} Display progress indicator while loading and a fallback icon on error.
\end{itemize}

\section{Non-functional requirements}
\subsection{Performance}
\begin{itemize}
    \item[NFR-01] App should display recipes list within 2 seconds on a typical mobile network after initial cache check.
    \item[NFR-02] Image loading should use cached images where available to reduce network latency.
\end{itemize}

\subsection{Reliability}
\begin{itemize}
    \item[NFR-03] The local DB must not lose user favorites on app restart.
    \item[NFR-04] On intermittent network, the app must gracefully fall back to cached data and queue write operations when back online.
\end{itemize}

\subsection{Security}
\begin{itemize}
    \item[NFR-05] Passwords must be transmitted securely (HTTPS recommended for production).
    \item[NFR-06] Sensitive tokens or session info must be stored securely in platform-appropriate secure storage.
\end{itemize}

\subsection{Usability}
\begin{itemize}
    \item[NFR-07] The UI shall be responsive and accessible on common screen sizes.
    \item[NFR-08] Password strength feedback and clear validation messages must be provided.
\end{itemize}

\subsection{Maintainability}
\begin{itemize}
    \item[NFR-09] Code must follow clean architecture separation and be modular to support future features.
\end{itemize}

\subsection{Portability}
\begin{itemize}
    \item[NFR-10] Application must be buildable for both Android and iOS.
\end{itemize}

\section{Database requirements}
\subsection{Schema}
A local SQLite database (recipes.db) with table \texttt{recipes}:

\begin{longtable}{p{4cm} p{10cm}}
\hline
\textbf{Column} & \textbf{Description / Type} \\
\hline
id & INTEGER PRIMARY KEY \\
name & TEXT \\
category & TEXT \\
time & TEXT (e.g., '30 mins') \\
calories & TEXT \\
image & TEXT (path or URL) \\
ingredients & TEXT (JSON encoded array) \\
mood & TEXT (JSON encoded array) \\
difficulty & TEXT \\
steps & TEXT (JSON encoded array) \\
isFavorite & INTEGER (0 or 1) \\
\hline
\end{longtable}

\subsection{Initial data}
Database to be pre-populated from \texttt{data/recipes.json} during first run.

\section{API contract (summary)}
\begin{enumerate}
    \item \textbf{GET /testConnection} — health check
    \item \textbf{POST /login} — body: \{email, password\}; response: user object + status
    \item \textbf{POST /register} — body: \{username, email, password\}; response: success boolean or error
    \item \textbf{PUT /user/username} — update username
    \item \textbf{POST /user/profile-picture} — multipart upload
    \item \textbf{GET /recipes} — fetch all recipes
    \item \textbf{POST /recipes} — multipart create new recipe
    \item \textbf{GET /recipes/{id}} — fetch single recipe
\end{enumerate}

(Exact request/response JSON shapes should be documented in the API specification implemented alongside the backend.)

\chapter{Use cases}
\section{Use case UC-01: Get recipe suggestion}
\textbf{Primary actor:} Registered user (or guest)\\
\textbf{Preconditions:} App launched; optional ingredients, mood, time provided.\\
\textbf{Main flow:}
\begin{enumerate}
    \item User selects ingredients they have.
    \item User selects mood and time constraint.
    \item System filters recipes and returns ranked results.
    \item User selects a recipe to view details.
\end{enumerate}

\section{Use case UC-02: Upload recipe}
\textbf{Primary actor:} Registered user\\
\textbf{Preconditions:} User authenticated.\\
\textbf{Main flow:}
\begin{enumerate}
    \item User opens recipe upload screen.
    \item User fills name, category, time, calories, ingredients, steps, mood tags and selects image.
    \item User submits; system uploads recipe and image to server and updates local DB on success.
\end{enumerate}

\chapter{Acceptance criteria and test plan}
\section{Acceptance criteria}
\begin{itemize}
    \item AC-01: User can register and login (email/password), and the returned profile matches UI state.
    \item AC-02: Searching/filtering returns relevant recipes based on name, category, mood, time and ingredients.
    \item AC-03: Favorites are persistent across app restarts and available offline.
    \item AC-04: Recipe upload with image succeeds and appears in user's recipes.
    \item AC-05: App gracefully handles network loss by using cached data.
\end{itemize}

\section{Testing strategy}
\begin{itemize}
    \item Unit tests for model parsing and utility functions (e.g., time-to-minutes conversion).
    \item Widget tests for main screens (rendering, input fields, buttons).
    \item Integration tests for major flows (login, fetch recipes, favorite/unfavorite, upload recipe).
    \item Manual acceptance testing for UI/UX and performance validation on real devices.
\end{itemize}

\chapter{Traceability matrix}
\begin{table}[h]
\centering
\begin{tabular}{|p{3cm}|p{9cm}|}
\hline
\textbf{Requirement ID} & \textbf{Mapped Test / Use Case} \\
\hline
FR-01, FR-02 & UC-Login, Test: Authentication unit/integration tests \\
FR-08, FR-09, FR-10, FR-11 & UC-Get recipe suggestion, Test: Search/filter integration tests \\
FR-12 & UC-Upload recipe, Test: Upload integration test \\
FR-13 & UC-Favorites, Test: Favorite persistence tests \\
FR-14 & UC-Offline behavior, Test: Offline acceptance tests \\
\hline
\end{tabular}
\caption{Requirement-to-test mapping}
\end{table}

\chapter{Appendices}
\section{Appendix A: UI screen list}
SplashScreen, LoginScreen, RegisterScreen, HomeScreen, RecipesScreen, RecipeDetailScreen, FavoritesScreen, ProfileScreen, RecipeUploadScreen.

\section{Appendix B: Data model examples}
\subsection*{Recipe JSON example}
\begin{verbatim}
{
  "id": 1,
  "name": "Tomato Pasta",
  "category": "Main Course",
  "time": "30 mins",
  "calories": "400",
  "image_path": "recipes/tomato_pasta.jpg",
  "ingredients": ["pasta", "tomato", "olive oil"],
  "steps": ["Boil pasta", "Make sauce", "Mix and serve"],
  "mood": ["Comfort"],
  "userId": 2
}
\end{verbatim}

\section{Appendix C: Open issues and future enhancements}
\begin{itemize}
    \item Add secure token refresh strategy and migrate backend to HTTPS in production.
    \item Add recommendation ranking algorithm (machine learning) for better personalization.
    \item Implement admin dashboard for content moderation.
    \item Support recipe sharing and social features.
\end{itemize}

\chapter*{Approval}
\begin{tabular}{p{6cm} p{6cm}}
Prepared by: & Reviewed by: \\
\vspace{2cm} & \vspace{2cm} \\
Signature: & Signature: \\
Date: \underline{\hspace{3cm}} & Date: \underline{\hspace{3cm}} \\
\end{tabular}

\end{document}
